// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#include "AbstractGPRDRSolver_ADERDG.h"
#include "kernels/GPRDR_GPRDRSolver_ADERDG/aderdg/Kernels.h"

#include "GPRDRSolver_ADERDG_Variables.h"
#include "GPRDRSolver_ADERDG.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

#include "kernels/GaussLegendreBasis.h"
#include "kernels/GaussLobattoBasis.h"

#include <stdio.h>


kernels::UnivariateFunction** GPRDR::AbstractGPRDRSolver_ADERDG::basisFunction                 = kernels::legendre::basisFunction;
kernels::UnivariateFunction** GPRDR::AbstractGPRDRSolver_ADERDG::basisFunctionFirstDerivative  = kernels::legendre::basisFunctionFirstDerivative;
kernels::UnivariateFunction** GPRDR::AbstractGPRDRSolver_ADERDG::basisFunctionSecondDerivative = kernels::legendre::basisFunctionSecondDerivative;

// We define the constructor of the actual solver here in order to regenerate it easily.
GPRDR::GPRDRSolver_ADERDG::GPRDRSolver_ADERDG(
    const double maximumMeshSize,
    const int maximumMeshDepth,
    const int haloCells,
    const int haloBufferCells,
    const int limiterBufferCells,
    const int regularisedFineGridLevels,
    const exahype::solvers::Solver::TimeStepping timeStepping,
    const int DMPObservables
):
    AbstractGPRDRSolver_ADERDG::AbstractGPRDRSolver_ADERDG(
        maximumMeshSize,
        maximumMeshDepth,
        haloCells,
        haloBufferCells,
        limiterBufferCells,
        regularisedFineGridLevels,
        timeStepping,
        DMPObservables
) {}

GPRDR::AbstractGPRDRSolver_ADERDG::AbstractGPRDRSolver_ADERDG(
    const double maximumMeshSize,
    const int maximumMeshDepth,
    const int haloCells,
    const int haloBufferCells,
    const int limiterBufferCells,
    const int regularisedFineGridLevels,
    const exahype::solvers::Solver::TimeStepping timeStepping,
    const int DMPObservables
)
    :
    exahype::solvers::ADERDGSolver(
        "GPRDRSolver_ADERDG",
        GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getNumberOfVariable(),
        GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getNumberOfParameter(),
        NumberOfGlobalObservables, // optimisations do not make sense here
        GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getBasisSize(),
        maximumMeshSize,
        maximumMeshDepth,
        haloCells,
        haloBufferCells,
        limiterBufferCells,
        regularisedFineGridLevels,
        timeStepping,
        DMPObservables
) {}

void GPRDR::AbstractGPRDRSolver_ADERDG::constantsToString(std::ostream& os) {
  // This string is used in the --version output to identify compile time constants
  os << "GPRDR::AbstractGPRDRSolver_ADERDG("
      << "nVar=" << NumberOfVariables << ", "
      << "nParam=" << NumberOfParameters << ", "
      << "nDim=" << Dimensions << ", "
      << "order=" << Order
      << ")";
}

int GPRDR::AbstractGPRDRSolver_ADERDG::fusedSpaceTimePredictorVolumeIntegral(double* lduh, double* lQhbnd, double* lGradQhbnd, double* lFhbnd, double* const luh, const tarch::la::Vector<DIMENSIONS, double>& cellCentre, const tarch::la::Vector<DIMENSIONS, double>& cellSize, const double t ,const double dt,const bool addVolumeIntegralResultToUpdate) {


  constexpr int totalSize = GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getFusedSTPVISize();
  double memory[totalSize] __attribute__((aligned(ALIGNMENT)));

  double* lQi = memory + GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getlQiShift();
  double* lQhi = memory + GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getlQhiShift();
  double* rhs = memory + GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getrhsShift(); //same size as lQi
  double* lFi = memory + GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getlFiShift();
  double* lFhi = memory + GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getlFhiShift();
  double* lSi = memory + GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getlSiShift();
  double* lShi = memory + GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getlShiShift();
  double* gradQ = memory + GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getgradQShift();
  double* gradQAvg = nullptr;

  // this switch should probably moved into the fusedSpaceTimePredictorVolumeIntegral kernel
  double  tempUpdate[GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getUpdateSize()] __attribute__((aligned(ALIGNMENT))); // TODO no heap variant implemented
  double* update = &tempUpdate[0]; // in order to not get tempUpdate optimised away
  if ( !addVolumeIntegralResultToUpdate ) {
    std::fill_n(tempUpdate,GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getUpdateSize(),0.0); // initialise with zeros
  } else {
    update = &lduh[0];
  }

  const int picardIt = GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::fusedSpaceTimePredictorVolumeIntegral(*static_cast<GPRDRSolver_ADERDG*>(this), update, lQhbnd, lGradQhbnd, lFhbnd, lQi, rhs, lFi, lSi, lQhi, lFhi, lShi, gradQ, gradQAvg, luh, 1./cellSize[0] /*inverseDx*/, dt);

  // this switch should probably moved into the fusedSpaceTimePredictorVolumeIntegral kernel
  if ( !addVolumeIntegralResultToUpdate ) {
    addUpdateToSolution(luh,luh,update,dt);
  }

  



  return picardIt;
}



void GPRDR::AbstractGPRDRSolver_ADERDG::addUpdateToSolution(double* const luh,const double* const luhOld,const double* const lduh,const double dt) {
  GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::solutionUpdate( luh, luhOld, lduh, dt );
 
}



void GPRDR::AbstractGPRDRSolver_ADERDG::surfaceIntegral(double* const lduh,const double* const lFhbnd,const tarch::la::Vector<DIMENSIONS,double>& cellSize) {
  GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::surfaceIntegral( lduh, lFhbnd, 1./cellSize[0] /*inverseDx*/ );
}



void GPRDR::AbstractGPRDRSolver_ADERDG::faceIntegral(double* const out/*may be solution or update vector*/,double* const lFhbnd,const int direction, const int orientation,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex,const int levelDelta,const tarch::la::Vector<DIMENSIONS, double>& cellSize,const double dt,const bool addToUpdate) {
  
  
  if ( levelDelta > 0 ) {
    double lFhbndCoarse[GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getBndFluxSize()] __attribute__((aligned(ALIGNMENT)));
    GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::faceFluxRestriction(lFhbndCoarse,lFhbnd,&subfaceIndex[0],levelDelta);

    tarch::la::Vector<DIMENSIONS,double> coarseGridCellSize = tarch::la::aPowI(levelDelta,3) * 1.0 * cellSize;
    GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::faceIntegral(out,lFhbndCoarse,direction,orientation,1./coarseGridCellSize[direction] /*inverseDxDirection*/);
  } else {
    if ( addToUpdate ) { // solution is only available in real cells, i.e. only here we can directly add the face integral result to the solution
      GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::faceIntegral(out,lFhbnd,direction,orientation,1./cellSize[direction]);
    } else {
      double update[GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getUpdateSize()] __attribute__((aligned(ALIGNMENT)));
      std::fill_n(update,GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getUpdateSize(),0.0);
      GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::faceIntegral(update,lFhbnd,direction,orientation,1./cellSize[direction]);
      addUpdateToSolution(out,out,update,dt); // adds update to solution out
    }
  }
}


void GPRDR::AbstractGPRDRSolver_ADERDG::riemannSolver(double* FL,double* FR,const double* const QL,const double* const QR,const double t,const double dt, const tarch::la::Vector<DIMENSIONS, double>& cellSize, const int direction, bool isBoundaryFace, int faceIndex) {
  assertion2(direction>=0,dt,direction);
  assertion2(direction<DIMENSIONS,dt,direction);
  GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::riemannSolver(*static_cast<GPRDRSolver_ADERDG*>(this), FL, FR, QL, QR, t, dt, cellSize[direction], direction);
}



void GPRDR::AbstractGPRDRSolver_ADERDG::boundaryConditions(double* const fluxIn,const double* const stateIn,const double* const gradStateIn, const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int direction,const int orientation) {

  double stateOut[GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getBndFaceSize()] __attribute__((aligned(ALIGNMENT)));
  double fluxOut[ GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::getBndFluxSize()] __attribute__((aligned(ALIGNMENT)));

  const int faceIndex = 2*direction+orientation;

  GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::boundaryConditions(*static_cast<GPRDRSolver_ADERDG*>(this), fluxOut, stateOut, fluxIn, stateIn, gradStateIn, &cellCentre[0], &cellSize[0], t, dt, faceIndex, direction);


  if (orientation == 0) {
    riemannSolver(fluxOut,fluxIn,stateOut,stateIn,t,dt,cellSize,direction,true,faceIndex);
  }
  else {
    riemannSolver(fluxIn,fluxOut,stateIn,stateOut,t,dt,cellSize,direction,true,faceIndex);
  }


}



double GPRDR::AbstractGPRDRSolver_ADERDG::stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellSize) {

  double d = GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::stableTimeStepSize(*static_cast<GPRDRSolver_ADERDG*>(this), luh, 1./cellSize[0] );

  return d;
}



void GPRDR::AbstractGPRDRSolver_ADERDG::adjustSolution(double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,double t,double dt) {

  GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::solutionAdjustment(*static_cast<GPRDRSolver_ADERDG*>(this), luh, &cellCentre[0], cellSize[0], t, dt );
}



void GPRDR::AbstractGPRDRSolver_ADERDG::faceUnknownsProlongation(double* const lQhbndFine,double* const lFhbndFine,const double* const lQhbndCoarse,const double* const lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {

  GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::faceUnknownsProlongation( lQhbndFine, lFhbndFine, lQhbndCoarse, lFhbndCoarse, coarseGridLevel, fineGridLevel, &subfaceIndex[0]);

}



void GPRDR::AbstractGPRDRSolver_ADERDG::volumeUnknownsProlongation(double* const luhFine,const double* const luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {

  GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::volumeUnknownsProlongation( luhFine, luhCoarse, coarseGridLevel, fineGridLevel, &subcellIndex[0]);

}



void GPRDR::AbstractGPRDRSolver_ADERDG::volumeUnknownsRestriction(double* const luhCoarse,const double* const luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {

  GPRDR::GPRDRSolver_ADERDG_kernels::aderdg::volumeUnknownsRestriction( luhCoarse, luhFine, coarseGridLevel, fineGridLevel, &subcellIndex[0]);

}

//--------


void GPRDR::AbstractGPRDRSolver_ADERDG::resetGlobalObservables(double* const globalObservables) {
}

void GPRDR::AbstractGPRDRSolver_ADERDG::updateGlobalObservables(
    double* const                               globalObservables,
    const double* const                         luh,
    const tarch::la::Vector<DIMENSIONS,double>& cellCentre,
    const tarch::la::Vector<DIMENSIONS,double>& cellSize,
    const double t,
    const double dt) {
}

void GPRDR::AbstractGPRDRSolver_ADERDG::mergeGlobalObservables(double* const globalObservables,const double* const otherObservables) {
}

void GPRDR::AbstractGPRDRSolver_ADERDG::wrapUpGlobalObservables(double* const globalObservables) {
}

//--------

void GPRDR::AbstractGPRDRSolver_ADERDG::abortWithMsg(const char* const msg) {
  // verbosily fail even without assertions turned on
  puts(msg);
  abort();
}

void GPRDR::AbstractGPRDRSolver_ADERDG::flux(const double* const Q,double** const F) {
  abortWithMsg("If this operation is entered (flux), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void GPRDR::AbstractGPRDRSolver_ADERDG::algebraicSource(const tarch::la::Vector<DIMENSIONS, double>& x, double t, const double *const Q, double *S) {
  abortWithMsg("If this operation is entered (algebraicSource), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void GPRDR::AbstractGPRDRSolver_ADERDG::nonConservativeProduct(const double* const Q,const double* const gradQ,double* const BgradQ) {
  abortWithMsg("If this operation is entered (nonConservativeProduct), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void GPRDR::AbstractGPRDRSolver_ADERDG::multiplyMaterialParameterMatrix(const double* const Q, double** const rhs) {
  abortWithMsg("multiplyMaterialParameterMatrix: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void GPRDR::AbstractGPRDRSolver_ADERDG::pointSource(const double* const Q,const double* const x,const double t,const double dt, double* const forceVector,int n) {
  abortWithMsg("If this operation is entered (pointSource), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void GPRDR::AbstractGPRDRSolver_ADERDG::viscousFlux(const double* const Q,const double* const gradQ, double** const F) {
  abortWithMsg("viscous flux: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void GPRDR::AbstractGPRDRSolver_ADERDG::viscousEigenvalues(const double* const Q,const int direction,double* const lambda) {
  abortWithMsg("viscous eigenvalues: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void GPRDR::AbstractGPRDRSolver_ADERDG::resetGlobalObservables(GlobalObservables& globalObservables) const {
  abortWithMsg("If this operation is entered (resetGlobalObservables), you have specified global observables. Then you have to re-implement this routine, too." );
}

void GPRDR::AbstractGPRDRSolver_ADERDG::mapGlobalObservables(
    GlobalObservables&                          globalObservables,
    const double* const                         luh,
    const tarch::la::Vector<DIMENSIONS,double>& cellCentre,
    const tarch::la::Vector<DIMENSIONS,double>& cellSize,
    const double t,
    const double dt) const {
  abortWithMsg("If this operation is entered (mapGlobalObservables), you have specified global observables. Then you have to re-implement this routine, too." );
}

void GPRDR::AbstractGPRDRSolver_ADERDG::mergeGlobalObservables(
    GlobalObservables&         globalObservables,
    ReadOnlyGlobalObservables& otherObservables) const {
  abortWithMsg("If this operation is entered (mergeGlobalObservables), you have specified global observables. Then you have to re-implement this routine, too." );
}

void GPRDR::AbstractGPRDRSolver_ADERDG::wrapUpGlobalObservables(GlobalObservables& globalObservables) const {
  // Please re-implement if required.
}

