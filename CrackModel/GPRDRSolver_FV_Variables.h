// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#ifndef __GPRDRSolver_FV_Variables_CLASS_HEADER__
#define __GPRDRSolver_FV_Variables_CLASS_HEADER__

#include "AbstractGPRDRSolver_FV.h"

#include <algorithm>

#include "tarch/la/Matrix.h"

/**
 * Generic information about the variable string as it was declared in the
 * specification file
 **/
struct GPRDR::AbstractGPRDRSolver_FV::VariableMetrics {
  static constexpr int numDistinctVariables = 14;
  static constexpr int SizeVariables  = 28; 
  static constexpr int SizeParameters = 0;
  static constexpr int Size           = 28+0;
  static constexpr int Dimensions     = DIMENSIONS;
};

/**
 * Positions of fields in the vector of unkonwns.
 *
 * With these constants, you can write Q[g11], Q[K22] and Q[B33] instead of
 * Q[0], Q[9] and Q[34]. Your code is meaningful in terms of physics while
 * you still access on a C-array level.
 *
 * You might want to use a typedef to shorten the notation or create 
 * an instance of this class.
 **/
class GPRDR::AbstractGPRDRSolver_FV::VariableShortcuts : public GPRDR::AbstractGPRDRSolver_FV::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
  const int _Q[numDistinctVariables + 1] = { 0,1,4,5,8,17,18,19,20,21,22,23,24,27 };

  const int rho = 0;
  const int v = 1;
  const int s = 4;
  const int J = 5;
  const int A = 8;
  const int alpha = 17;
  const int lambda = 18;
  const int mu = 19;
  const int xi = 20;
  const int xi1 = 21;
  const int sliding = 22;
  const int sliding_xi = 23;
  const int slip = 24;
  const int derivY = 27;

  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableShortcuts

/**
 * Lengths (multplicities) of each field inside the unknown vector Q.
 * For instance, 0 means "scalar field" while any value >0 may mean a vector field or
 * even a "linearized" tensor field
 **/
class GPRDR::AbstractGPRDRSolver_FV::VariableMultiplicities : public GPRDR::AbstractGPRDRSolver_FV::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
 
  const int _Q[numDistinctVariables] = { 1,3,1,3,9,1,1,1,1,1,1,1,3,1 };

  const int rho = 1;
  const int v = 3;
  const int s = 1;
  const int J = 3;
  const int A = 9;
  const int alpha = 1;
  const int lambda = 1;
  const int mu = 1;
  const int xi = 1;
  const int xi1 = 1;
  const int sliding = 1;
  const int sliding_xi = 1;
  const int slip = 3;
  const int derivY = 1;

  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableMultiplicities

/**
 * Variable names as strings as given in the toolkit.
 * 
 * These names might want to be used for plotting, output, etc.
 *
 **/
class GPRDR::AbstractGPRDRSolver_FV::VariableNames : public GPRDR::AbstractGPRDRSolver_FV::VariableMetrics {
public:
  char const *_Q[numDistinctVariables + 1] = { "rho","v","s","J","A","alpha","lambda","mu","xi","xi1","sliding","sliding_xi","slip","derivY" };

  const char* rho = "rho";
  const char* v = "v";
  const char* s = "s";
  const char* J = "J";
  const char* A = "A";
  const char* alpha = "alpha";
  const char* lambda = "lambda";
  const char* mu = "mu";
  const char* xi = "xi";
  const char* xi1 = "xi1";
  const char* sliding = "sliding";
  const char* sliding_xi = "sliding_xi";
  const char* slip = "slip";
  const char* derivY = "derivY";

  const char* const* asArray() const { return _Q; } // type: whatever
  const char* operator [] (int index) const { return _Q[index]; }
  const char* operator () (int index) const { return _Q[index]; }
}; // end of VariableNames

/**
 * Positions of fields in the vector of unknowns,
 * available as namespace constants.
 * 
 * You can use this namespace similar to the class "VariableShortcuts"
 * but you don't need an object, ie. your notation can get slimmer.
 * 
 * Usage is like:
 * 
 *    void somewhere() {
 *       using namespace GPRDR::GPRDRSolver_FV_Variables::shortcuts;
 *       Q[foo] = 17;
 *    }
 *
 * instead of
 * 
 *    void somewhere() {
 *       GPRDR::AbstractGPRDRSolver_FV::VariableNames q;
 *       Q[q.foo] = 17;
 *    }
 *
 **/
namespace GPRDR {
  namespace GPRDRSolver_FV_Variables {
    namespace shortcuts {
      constexpr int rho = 0;
      constexpr int v = 1;
      constexpr int s = 4;
      constexpr int J = 5;
      constexpr int A = 8;
      constexpr int alpha = 17;
      constexpr int lambda = 18;
      constexpr int mu = 19;
      constexpr int xi = 20;
      constexpr int xi1 = 21;
      constexpr int sliding = 22;
      constexpr int sliding_xi = 23;
      constexpr int slip = 24;
      constexpr int derivY = 27;
    } // namespace shortcuts
    namespace names {
      constexpr char rho[] = "rho"; 
      constexpr char v[] = "v"; 
      constexpr char s[] = "s"; 
      constexpr char J[] = "J"; 
      constexpr char A[] = "A"; 
      constexpr char alpha[] = "alpha"; 
      constexpr char lambda[] = "lambda"; 
      constexpr char mu[] = "mu"; 
      constexpr char xi[] = "xi"; 
      constexpr char xi1[] = "xi1"; 
      constexpr char sliding[] = "sliding"; 
      constexpr char sliding_xi[] = "sliding_xi"; 
      constexpr char slip[] = "slip"; 
      constexpr char derivY[] = "derivY"; 
    } // namespace names
  } // end of namespace GPRDR::GPRDRSolver_FV_Variables 
} // end of namespace GPRDR

/*
 * Another class idea:
 * 
 * class ....::VariablePointers {
 *   private:   double* Q;
 *   public:
 *      double &varfoo;
 *      double &varbar;
 *      VariablePointers(double* const Q) : varfoo(Q[0]), bar(Q[1]), ... {}
 * }
 * 
 * Advantages: Use as positions in Q.
 *
 */


class GPRDR::AbstractGPRDRSolver_FV::ReadOnlyVariables : public GPRDR::AbstractGPRDRSolver_FV::VariableMetrics {
  private:
    const double* const _Q;
  public:
    ReadOnlyVariables(const double* const Q) : _Q(Q) {}
    
    double operator [] (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double operator () (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    const double* data() const {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

    // getter and setter for rho
    double rho() const {return _Q[0];}
        
    // getters for v 
    double v(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[1+index];
    }
    tarch::la::Vector<3,double> v() const {
      tarch::la::Vector<3,double> values;
      values=_Q[1],_Q[2],_Q[3];
      return values;
    }
        
    // getter and setter for s
    double s() const {return _Q[4];}
        
    // getters for J 
    double J(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[5+index];
    }
    tarch::la::Vector<3,double> J() const {
      tarch::la::Vector<3,double> values;
      values=_Q[5],_Q[6],_Q[7];
      return values;
    }
        
    // getters for A 
    double A(int index) const {
      assertion(index >= 0 && index<9);
      return _Q[8+index];
    }
    tarch::la::Vector<9,double> A() const {
      tarch::la::Vector<9,double> values;
      values=_Q[8],_Q[9],_Q[10],_Q[11],_Q[12],_Q[13],_Q[14],_Q[15],_Q[16];
      return values;
    }
        
    // getter and setter for alpha
    double alpha() const {return _Q[17];}
        
    // getter and setter for lambda
    double lambda() const {return _Q[18];}
        
    // getter and setter for mu
    double mu() const {return _Q[19];}
        
    // getter and setter for xi
    double xi() const {return _Q[20];}
        
    // getter and setter for xi1
    double xi1() const {return _Q[21];}
        
    // getter and setter for sliding
    double sliding() const {return _Q[22];}
        
    // getter and setter for sliding_xi
    double sliding_xi() const {return _Q[23];}
        
    // getters for slip 
    double slip(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[24+index];
    }
    tarch::la::Vector<3,double> slip() const {
      tarch::la::Vector<3,double> values;
      values=_Q[24],_Q[25],_Q[26];
      return values;
    }
        
    // getter and setter for derivY
    double derivY() const {return _Q[27];}
        
}; // end of ReadOnlyVariables


class GPRDR::AbstractGPRDRSolver_FV::Variables : public GPRDR::AbstractGPRDRSolver_FV::VariableMetrics{
  private:
    double* const _Q;
  public:
    static constexpr int SizeVariables  = 28;
    static constexpr int SizeParameters = 0;
    static constexpr int Size           = 28+0;
  
    Variables(double* const Q) : _Q(Q) {}
    
    void operator = (Variables& variables) {
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    void operator = (ReadOnlyVariables& variables) {
      assertion(variables.variables()==SizeVariables);
      assertion(variables.parameters()==SizeParameters);
      assertion(variables.size()==Size);
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double* data() {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

    // getter and setter for rho
    double rho() const {return _Q[0];}
    double& rho() {return _Q[0];}
    
    // getters for v 
    double v(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[1+index];
    }
    tarch::la::Vector<3,double> v() const {
      tarch::la::Vector<3,double> values;
      values=_Q[1],_Q[2],_Q[3];
      return values;
    }
    // setters for v
    double& v(int index) {return _Q[1+index];}
    void v(const tarch::la::Vector<3,double>& values) const {
      _Q[1] = values[0];
      _Q[2] = values[1];
      _Q[3] = values[2];
    }
    void v(double v0,double v1,double v2) {
      _Q[1] = v0;
      _Q[2] = v1;
      _Q[3] = v2;
    }
    
    // getter and setter for s
    double s() const {return _Q[4];}
    double& s() {return _Q[4];}
    
    // getters for J 
    double J(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[5+index];
    }
    tarch::la::Vector<3,double> J() const {
      tarch::la::Vector<3,double> values;
      values=_Q[5],_Q[6],_Q[7];
      return values;
    }
    // setters for J
    double& J(int index) {return _Q[5+index];}
    void J(const tarch::la::Vector<3,double>& values) const {
      _Q[5] = values[0];
      _Q[6] = values[1];
      _Q[7] = values[2];
    }
    void J(double J0,double J1,double J2) {
      _Q[5] = J0;
      _Q[6] = J1;
      _Q[7] = J2;
    }
    
    // getters for A 
    double A(int index) const {
      assertion(index >= 0 && index<9);
      return _Q[8+index];
    }
    tarch::la::Vector<9,double> A() const {
      tarch::la::Vector<9,double> values;
      values=_Q[8],_Q[9],_Q[10],_Q[11],_Q[12],_Q[13],_Q[14],_Q[15],_Q[16];
      return values;
    }
    // setters for A
    double& A(int index) {return _Q[8+index];}
    void A(const tarch::la::Vector<9,double>& values) const {
      _Q[8] = values[0];
      _Q[9] = values[1];
      _Q[10] = values[2];
      _Q[11] = values[3];
      _Q[12] = values[4];
      _Q[13] = values[5];
      _Q[14] = values[6];
      _Q[15] = values[7];
      _Q[16] = values[8];
    }
    void A(double A0,double A1,double A2,double A3,double A4,double A5,double A6,double A7,double A8) {
      _Q[8] = A0;
      _Q[9] = A1;
      _Q[10] = A2;
      _Q[11] = A3;
      _Q[12] = A4;
      _Q[13] = A5;
      _Q[14] = A6;
      _Q[15] = A7;
      _Q[16] = A8;
    }
    
    // getter and setter for alpha
    double alpha() const {return _Q[17];}
    double& alpha() {return _Q[17];}
    
    // getter and setter for lambda
    double lambda() const {return _Q[18];}
    double& lambda() {return _Q[18];}
    
    // getter and setter for mu
    double mu() const {return _Q[19];}
    double& mu() {return _Q[19];}
    
    // getter and setter for xi
    double xi() const {return _Q[20];}
    double& xi() {return _Q[20];}
    
    // getter and setter for xi1
    double xi1() const {return _Q[21];}
    double& xi1() {return _Q[21];}
    
    // getter and setter for sliding
    double sliding() const {return _Q[22];}
    double& sliding() {return _Q[22];}
    
    // getter and setter for sliding_xi
    double sliding_xi() const {return _Q[23];}
    double& sliding_xi() {return _Q[23];}
    
    // getters for slip 
    double slip(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[24+index];
    }
    tarch::la::Vector<3,double> slip() const {
      tarch::la::Vector<3,double> values;
      values=_Q[24],_Q[25],_Q[26];
      return values;
    }
    // setters for slip
    double& slip(int index) {return _Q[24+index];}
    void slip(const tarch::la::Vector<3,double>& values) const {
      _Q[24] = values[0];
      _Q[25] = values[1];
      _Q[26] = values[2];
    }
    void slip(double slip0,double slip1,double slip2) {
      _Q[24] = slip0;
      _Q[25] = slip1;
      _Q[26] = slip2;
    }
    
    // getter and setter for derivY
    double derivY() const {return _Q[27];}
    double& derivY() {return _Q[27];}
    
}; // end of Variables


class GPRDR::AbstractGPRDRSolver_FV::Fluxes : public GPRDR::AbstractGPRDRSolver_FV::VariableMetrics {
  private:
    double** const _F;
  public:
    Fluxes(double** const F) : _F(F) {}
    
    /** The rows of the flux tensor. */
    int variables() const {
      return SizeVariables;
    }
    
    /** The columns of the flux tensor. */
    int dimensions() const {
      return Dimensions;
    }


    // getters for rho
    double rho(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0];
    }
    tarch::la::Vector<DIMENSIONS,double> rho() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0],_F[1][0]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0],_F[1][0],_F[2][0]);
      #endif
      return values;
    }
    // setters for rho
    double& rho(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0];
    }

    void rho(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][0] = values[0];
      _F[1][0] = values[1];
      #if DIMENSIONS==3
      _F[2][0] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void rho(const tarch::la::Vector<3,double>& values) {
      _F[0][0] = values[0];
      _F[1][0] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void rho(double v0,double v1,double v2) {
      _F[0][0] = v0;
      _F[1][0] = v1;
      #if DIMENSIONS==3
      _F[2][0] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void rho(double v0,double v1) {
      _F[0][0] = v0;
      _F[1][0] = v1;
    }
    #endif
    // getters for v
    double v(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][1+row];
    }
    tarch::la::Vector<DIMENSIONS,double> v(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][1+row],_F[1][1+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][1+row],_F[1][1+row],_F[2][1+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<3,DIMENSIONS,double> v() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][1+0],_F[1][1+0],
_F[0][1+1],_F[1][1+1],
_F[0][1+2],_F[1][1+2];
      #elif DIMENSIONS==3
      values = 
_F[0][1+0],_F[1][1+0],_F[2][1+0],
_F[0][1+1],_F[1][1+1],_F[2][1+1],
_F[0][1+2],_F[1][1+2],_F[2][1+2];
      #endif
      return values;
    }
    // setters for v
    double& v(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][1+row];
    }

    void v(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][1+0] = values(0,0);
      _F[0][1+1] = values(1,0);
      _F[0][1+2] = values(2,0);
      _F[1][1+0] = values(0,1);
      _F[1][1+1] = values(1,1);
      _F[1][1+2] = values(2,1);
      #if DIMENSIONS==3
      _F[2][1+0] = values(0,2);
      _F[2][1+1] = values(1,2);
      _F[2][1+2] = values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void v(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][1+0] = values(0,0);
      _F[0][1+1] = values(1,0);
      _F[0][1+2] = values(2,0);
      _F[1][1+0] = values(0,1);
      _F[1][1+1] = values(1,1);
      _F[1][1+2] = values(2,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void v(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][1+row] = v0;
      _F[1][1+row] = v1;
      #if DIMENSIONS==3
      _F[2][1+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void v(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][1+row] = v0;
      _F[1][1+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void v(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22) {
      _F[0][1+0] = v00;
      _F[0][1+1] = v10;
      _F[0][1+2] = v20;
      _F[1][1+0] = v01;
      _F[1][1+1] = v11;
      _F[1][1+2] = v21;
      #if DIMENSIONS==3
      _F[2][1+0] = v02;
      _F[2][1+1] = v12;
      _F[2][1+2] = v22;
      #endif
    }
    #if DIMENSIONS==2
    void v(double v00,double v01,double v10,double v11,double v20,double v21) {
      _F[0][1+0] = v00;
      _F[0][1+1] = v10;
      _F[0][1+2] = v20;
      _F[1][1+0] = v01;
      _F[1][1+1] = v11;
      _F[1][1+2] = v21;
    }
    #endif
    // getters for s
    double s(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][4];
    }
    tarch::la::Vector<DIMENSIONS,double> s() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][4],_F[1][4]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][4],_F[1][4],_F[2][4]);
      #endif
      return values;
    }
    // setters for s
    double& s(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][4];
    }

    void s(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][4] = values[0];
      _F[1][4] = values[1];
      #if DIMENSIONS==3
      _F[2][4] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void s(const tarch::la::Vector<3,double>& values) {
      _F[0][4] = values[0];
      _F[1][4] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void s(double v0,double v1,double v2) {
      _F[0][4] = v0;
      _F[1][4] = v1;
      #if DIMENSIONS==3
      _F[2][4] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void s(double v0,double v1) {
      _F[0][4] = v0;
      _F[1][4] = v1;
    }
    #endif
    // getters for J
    double J(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][5+row];
    }
    tarch::la::Vector<DIMENSIONS,double> J(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][5+row],_F[1][5+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][5+row],_F[1][5+row],_F[2][5+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<3,DIMENSIONS,double> J() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][5+0],_F[1][5+0],
_F[0][5+1],_F[1][5+1],
_F[0][5+2],_F[1][5+2];
      #elif DIMENSIONS==3
      values = 
_F[0][5+0],_F[1][5+0],_F[2][5+0],
_F[0][5+1],_F[1][5+1],_F[2][5+1],
_F[0][5+2],_F[1][5+2],_F[2][5+2];
      #endif
      return values;
    }
    // setters for J
    double& J(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][5+row];
    }

    void J(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][5+0] = values(0,0);
      _F[0][5+1] = values(1,0);
      _F[0][5+2] = values(2,0);
      _F[1][5+0] = values(0,1);
      _F[1][5+1] = values(1,1);
      _F[1][5+2] = values(2,1);
      #if DIMENSIONS==3
      _F[2][5+0] = values(0,2);
      _F[2][5+1] = values(1,2);
      _F[2][5+2] = values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void J(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][5+0] = values(0,0);
      _F[0][5+1] = values(1,0);
      _F[0][5+2] = values(2,0);
      _F[1][5+0] = values(0,1);
      _F[1][5+1] = values(1,1);
      _F[1][5+2] = values(2,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void J(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][5+row] = v0;
      _F[1][5+row] = v1;
      #if DIMENSIONS==3
      _F[2][5+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void J(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][5+row] = v0;
      _F[1][5+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void J(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22) {
      _F[0][5+0] = v00;
      _F[0][5+1] = v10;
      _F[0][5+2] = v20;
      _F[1][5+0] = v01;
      _F[1][5+1] = v11;
      _F[1][5+2] = v21;
      #if DIMENSIONS==3
      _F[2][5+0] = v02;
      _F[2][5+1] = v12;
      _F[2][5+2] = v22;
      #endif
    }
    #if DIMENSIONS==2
    void J(double v00,double v01,double v10,double v11,double v20,double v21) {
      _F[0][5+0] = v00;
      _F[0][5+1] = v10;
      _F[0][5+2] = v20;
      _F[1][5+0] = v01;
      _F[1][5+1] = v11;
      _F[1][5+2] = v21;
    }
    #endif
    // getters for A
    double A(int row, int column) const {
      assertion(row >= 0 && row<9);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][8+row];
    }
    tarch::la::Vector<DIMENSIONS,double> A(int row) const {
      assertion(row >= 0 && row<9);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][8+row],_F[1][8+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][8+row],_F[1][8+row],_F[2][8+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<9,DIMENSIONS,double> A() const {
      tarch::la::Matrix<9,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][8+0],_F[1][8+0],
_F[0][8+1],_F[1][8+1],
_F[0][8+2],_F[1][8+2],
_F[0][8+3],_F[1][8+3],
_F[0][8+4],_F[1][8+4],
_F[0][8+5],_F[1][8+5],
_F[0][8+6],_F[1][8+6],
_F[0][8+7],_F[1][8+7],
_F[0][8+8],_F[1][8+8];
      #elif DIMENSIONS==3
      values = 
_F[0][8+0],_F[1][8+0],_F[2][8+0],
_F[0][8+1],_F[1][8+1],_F[2][8+1],
_F[0][8+2],_F[1][8+2],_F[2][8+2],
_F[0][8+3],_F[1][8+3],_F[2][8+3],
_F[0][8+4],_F[1][8+4],_F[2][8+4],
_F[0][8+5],_F[1][8+5],_F[2][8+5],
_F[0][8+6],_F[1][8+6],_F[2][8+6],
_F[0][8+7],_F[1][8+7],_F[2][8+7],
_F[0][8+8],_F[1][8+8],_F[2][8+8];
      #endif
      return values;
    }
    // setters for A
    double& A(int row, int column) {
      assertion(row >= 0 && row<9);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][8+row];
    }

    void A(const tarch::la::Matrix<9,DIMENSIONS,double>& values) {
      _F[0][8+0] = values(0,0);
      _F[0][8+1] = values(1,0);
      _F[0][8+2] = values(2,0);
      _F[0][8+3] = values(3,0);
      _F[0][8+4] = values(4,0);
      _F[0][8+5] = values(5,0);
      _F[0][8+6] = values(6,0);
      _F[0][8+7] = values(7,0);
      _F[0][8+8] = values(8,0);
      _F[1][8+0] = values(0,1);
      _F[1][8+1] = values(1,1);
      _F[1][8+2] = values(2,1);
      _F[1][8+3] = values(3,1);
      _F[1][8+4] = values(4,1);
      _F[1][8+5] = values(5,1);
      _F[1][8+6] = values(6,1);
      _F[1][8+7] = values(7,1);
      _F[1][8+8] = values(8,1);
      #if DIMENSIONS==3
      _F[2][8+0] = values(0,2);
      _F[2][8+1] = values(1,2);
      _F[2][8+2] = values(2,2);
      _F[2][8+3] = values(3,2);
      _F[2][8+4] = values(4,2);
      _F[2][8+5] = values(5,2);
      _F[2][8+6] = values(6,2);
      _F[2][8+7] = values(7,2);
      _F[2][8+8] = values(8,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void A(const tarch::la::Matrix<9,3,double>& values) {
      _F[0][8+0] = values(0,0);
      _F[0][8+1] = values(1,0);
      _F[0][8+2] = values(2,0);
      _F[0][8+3] = values(3,0);
      _F[0][8+4] = values(4,0);
      _F[0][8+5] = values(5,0);
      _F[0][8+6] = values(6,0);
      _F[0][8+7] = values(7,0);
      _F[0][8+8] = values(8,0);
      _F[1][8+0] = values(0,1);
      _F[1][8+1] = values(1,1);
      _F[1][8+2] = values(2,1);
      _F[1][8+3] = values(3,1);
      _F[1][8+4] = values(4,1);
      _F[1][8+5] = values(5,1);
      _F[1][8+6] = values(6,1);
      _F[1][8+7] = values(7,1);
      _F[1][8+8] = values(8,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void A(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<9);
      _F[0][8+row] = v0;
      _F[1][8+row] = v1;
      #if DIMENSIONS==3
      _F[2][8+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void A(int row, double v0,double v1) {
      assertion(row >= 0 && row<9);
      _F[0][8+row] = v0;
      _F[1][8+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void A(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22,double v30,double v31,double v32,double v40,double v41,double v42,double v50,double v51,double v52,double v60,double v61,double v62,double v70,double v71,double v72,double v80,double v81,double v82) {
      _F[0][8+0] = v00;
      _F[0][8+1] = v10;
      _F[0][8+2] = v20;
      _F[0][8+3] = v30;
      _F[0][8+4] = v40;
      _F[0][8+5] = v50;
      _F[0][8+6] = v60;
      _F[0][8+7] = v70;
      _F[0][8+8] = v80;
      _F[1][8+0] = v01;
      _F[1][8+1] = v11;
      _F[1][8+2] = v21;
      _F[1][8+3] = v31;
      _F[1][8+4] = v41;
      _F[1][8+5] = v51;
      _F[1][8+6] = v61;
      _F[1][8+7] = v71;
      _F[1][8+8] = v81;
      #if DIMENSIONS==3
      _F[2][8+0] = v02;
      _F[2][8+1] = v12;
      _F[2][8+2] = v22;
      _F[2][8+3] = v32;
      _F[2][8+4] = v42;
      _F[2][8+5] = v52;
      _F[2][8+6] = v62;
      _F[2][8+7] = v72;
      _F[2][8+8] = v82;
      #endif
    }
    #if DIMENSIONS==2
    void A(double v00,double v01,double v10,double v11,double v20,double v21,double v30,double v31,double v40,double v41,double v50,double v51,double v60,double v61,double v70,double v71,double v80,double v81) {
      _F[0][8+0] = v00;
      _F[0][8+1] = v10;
      _F[0][8+2] = v20;
      _F[0][8+3] = v30;
      _F[0][8+4] = v40;
      _F[0][8+5] = v50;
      _F[0][8+6] = v60;
      _F[0][8+7] = v70;
      _F[0][8+8] = v80;
      _F[1][8+0] = v01;
      _F[1][8+1] = v11;
      _F[1][8+2] = v21;
      _F[1][8+3] = v31;
      _F[1][8+4] = v41;
      _F[1][8+5] = v51;
      _F[1][8+6] = v61;
      _F[1][8+7] = v71;
      _F[1][8+8] = v81;
    }
    #endif
    // getters for alpha
    double alpha(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][17];
    }
    tarch::la::Vector<DIMENSIONS,double> alpha() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][17],_F[1][17]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][17],_F[1][17],_F[2][17]);
      #endif
      return values;
    }
    // setters for alpha
    double& alpha(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][17];
    }

    void alpha(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][17] = values[0];
      _F[1][17] = values[1];
      #if DIMENSIONS==3
      _F[2][17] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void alpha(const tarch::la::Vector<3,double>& values) {
      _F[0][17] = values[0];
      _F[1][17] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void alpha(double v0,double v1,double v2) {
      _F[0][17] = v0;
      _F[1][17] = v1;
      #if DIMENSIONS==3
      _F[2][17] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void alpha(double v0,double v1) {
      _F[0][17] = v0;
      _F[1][17] = v1;
    }
    #endif
    // getters for lambda
    double lambda(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][18];
    }
    tarch::la::Vector<DIMENSIONS,double> lambda() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][18],_F[1][18]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][18],_F[1][18],_F[2][18]);
      #endif
      return values;
    }
    // setters for lambda
    double& lambda(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][18];
    }

    void lambda(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][18] = values[0];
      _F[1][18] = values[1];
      #if DIMENSIONS==3
      _F[2][18] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void lambda(const tarch::la::Vector<3,double>& values) {
      _F[0][18] = values[0];
      _F[1][18] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void lambda(double v0,double v1,double v2) {
      _F[0][18] = v0;
      _F[1][18] = v1;
      #if DIMENSIONS==3
      _F[2][18] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void lambda(double v0,double v1) {
      _F[0][18] = v0;
      _F[1][18] = v1;
    }
    #endif
    // getters for mu
    double mu(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][19];
    }
    tarch::la::Vector<DIMENSIONS,double> mu() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][19],_F[1][19]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][19],_F[1][19],_F[2][19]);
      #endif
      return values;
    }
    // setters for mu
    double& mu(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][19];
    }

    void mu(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][19] = values[0];
      _F[1][19] = values[1];
      #if DIMENSIONS==3
      _F[2][19] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void mu(const tarch::la::Vector<3,double>& values) {
      _F[0][19] = values[0];
      _F[1][19] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void mu(double v0,double v1,double v2) {
      _F[0][19] = v0;
      _F[1][19] = v1;
      #if DIMENSIONS==3
      _F[2][19] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void mu(double v0,double v1) {
      _F[0][19] = v0;
      _F[1][19] = v1;
    }
    #endif
    // getters for xi
    double xi(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][20];
    }
    tarch::la::Vector<DIMENSIONS,double> xi() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][20],_F[1][20]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][20],_F[1][20],_F[2][20]);
      #endif
      return values;
    }
    // setters for xi
    double& xi(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][20];
    }

    void xi(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][20] = values[0];
      _F[1][20] = values[1];
      #if DIMENSIONS==3
      _F[2][20] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void xi(const tarch::la::Vector<3,double>& values) {
      _F[0][20] = values[0];
      _F[1][20] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void xi(double v0,double v1,double v2) {
      _F[0][20] = v0;
      _F[1][20] = v1;
      #if DIMENSIONS==3
      _F[2][20] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void xi(double v0,double v1) {
      _F[0][20] = v0;
      _F[1][20] = v1;
    }
    #endif
    // getters for xi1
    double xi1(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][21];
    }
    tarch::la::Vector<DIMENSIONS,double> xi1() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][21],_F[1][21]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][21],_F[1][21],_F[2][21]);
      #endif
      return values;
    }
    // setters for xi1
    double& xi1(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][21];
    }

    void xi1(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][21] = values[0];
      _F[1][21] = values[1];
      #if DIMENSIONS==3
      _F[2][21] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void xi1(const tarch::la::Vector<3,double>& values) {
      _F[0][21] = values[0];
      _F[1][21] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void xi1(double v0,double v1,double v2) {
      _F[0][21] = v0;
      _F[1][21] = v1;
      #if DIMENSIONS==3
      _F[2][21] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void xi1(double v0,double v1) {
      _F[0][21] = v0;
      _F[1][21] = v1;
    }
    #endif
    // getters for sliding
    double sliding(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][22];
    }
    tarch::la::Vector<DIMENSIONS,double> sliding() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][22],_F[1][22]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][22],_F[1][22],_F[2][22]);
      #endif
      return values;
    }
    // setters for sliding
    double& sliding(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][22];
    }

    void sliding(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][22] = values[0];
      _F[1][22] = values[1];
      #if DIMENSIONS==3
      _F[2][22] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void sliding(const tarch::la::Vector<3,double>& values) {
      _F[0][22] = values[0];
      _F[1][22] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void sliding(double v0,double v1,double v2) {
      _F[0][22] = v0;
      _F[1][22] = v1;
      #if DIMENSIONS==3
      _F[2][22] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void sliding(double v0,double v1) {
      _F[0][22] = v0;
      _F[1][22] = v1;
    }
    #endif
    // getters for sliding_xi
    double sliding_xi(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][23];
    }
    tarch::la::Vector<DIMENSIONS,double> sliding_xi() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][23],_F[1][23]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][23],_F[1][23],_F[2][23]);
      #endif
      return values;
    }
    // setters for sliding_xi
    double& sliding_xi(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][23];
    }

    void sliding_xi(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][23] = values[0];
      _F[1][23] = values[1];
      #if DIMENSIONS==3
      _F[2][23] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void sliding_xi(const tarch::la::Vector<3,double>& values) {
      _F[0][23] = values[0];
      _F[1][23] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void sliding_xi(double v0,double v1,double v2) {
      _F[0][23] = v0;
      _F[1][23] = v1;
      #if DIMENSIONS==3
      _F[2][23] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void sliding_xi(double v0,double v1) {
      _F[0][23] = v0;
      _F[1][23] = v1;
    }
    #endif
    // getters for slip
    double slip(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][24+row];
    }
    tarch::la::Vector<DIMENSIONS,double> slip(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][24+row],_F[1][24+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][24+row],_F[1][24+row],_F[2][24+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<3,DIMENSIONS,double> slip() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][24+0],_F[1][24+0],
_F[0][24+1],_F[1][24+1],
_F[0][24+2],_F[1][24+2];
      #elif DIMENSIONS==3
      values = 
_F[0][24+0],_F[1][24+0],_F[2][24+0],
_F[0][24+1],_F[1][24+1],_F[2][24+1],
_F[0][24+2],_F[1][24+2],_F[2][24+2];
      #endif
      return values;
    }
    // setters for slip
    double& slip(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][24+row];
    }

    void slip(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][24+0] = values(0,0);
      _F[0][24+1] = values(1,0);
      _F[0][24+2] = values(2,0);
      _F[1][24+0] = values(0,1);
      _F[1][24+1] = values(1,1);
      _F[1][24+2] = values(2,1);
      #if DIMENSIONS==3
      _F[2][24+0] = values(0,2);
      _F[2][24+1] = values(1,2);
      _F[2][24+2] = values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void slip(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][24+0] = values(0,0);
      _F[0][24+1] = values(1,0);
      _F[0][24+2] = values(2,0);
      _F[1][24+0] = values(0,1);
      _F[1][24+1] = values(1,1);
      _F[1][24+2] = values(2,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void slip(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][24+row] = v0;
      _F[1][24+row] = v1;
      #if DIMENSIONS==3
      _F[2][24+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void slip(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][24+row] = v0;
      _F[1][24+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void slip(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22) {
      _F[0][24+0] = v00;
      _F[0][24+1] = v10;
      _F[0][24+2] = v20;
      _F[1][24+0] = v01;
      _F[1][24+1] = v11;
      _F[1][24+2] = v21;
      #if DIMENSIONS==3
      _F[2][24+0] = v02;
      _F[2][24+1] = v12;
      _F[2][24+2] = v22;
      #endif
    }
    #if DIMENSIONS==2
    void slip(double v00,double v01,double v10,double v11,double v20,double v21) {
      _F[0][24+0] = v00;
      _F[0][24+1] = v10;
      _F[0][24+2] = v20;
      _F[1][24+0] = v01;
      _F[1][24+1] = v11;
      _F[1][24+2] = v21;
    }
    #endif
    // getters for derivY
    double derivY(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][27];
    }
    tarch::la::Vector<DIMENSIONS,double> derivY() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][27],_F[1][27]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][27],_F[1][27],_F[2][27]);
      #endif
      return values;
    }
    // setters for derivY
    double& derivY(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][27];
    }

    void derivY(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][27] = values[0];
      _F[1][27] = values[1];
      #if DIMENSIONS==3
      _F[2][27] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void derivY(const tarch::la::Vector<3,double>& values) {
      _F[0][27] = values[0];
      _F[1][27] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void derivY(double v0,double v1,double v2) {
      _F[0][27] = v0;
      _F[1][27] = v1;
      #if DIMENSIONS==3
      _F[2][27] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void derivY(double v0,double v1) {
      _F[0][27] = v0;
      _F[1][27] = v1;
    }
    #endif
}; // end of Fluxes

// NamingSchemes:

//
// Global Observables
//
class GPRDR::AbstractGPRDRSolver_FV::ReadOnlyGlobalObservables {
  private:
    const double* const _observables;
  public:
    static constexpr int Size = 0;
    
    ReadOnlyGlobalObservables(const double* const observables) : _observables(observables) {}
    
    double operator [] (int index) const {
      assertion(index>=0 && index < Size);
      return _observables[index];
    }
    
    double operator () (int index) const {
      assertion(index>=0 && index < Size);
      return _observables[index];
    }
    
    const double* data() const {
      return _observables;
    }
    
    int size() const {
      return Size;
    }

}; // end of ReadOnlyGlobalObservables


class GPRDR::AbstractGPRDRSolver_FV::GlobalObservables {
  private:
    double* const _observables;
  public:
    static constexpr int Size = 0;
  
    GlobalObservables(double* const observables) : _observables(observables) {}
    
    void operator = (GlobalObservables& observables) {
      std::copy(observables.data(),observables.data()+Size,_observables);
    }
    
    void operator = (ReadOnlyGlobalObservables& observables) {
      assertion(observables.size()==Size);
      std::copy(observables.data(),observables.data()+Size,_observables);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _observables[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _observables[index];
    }
    
    double* data() {
      return _observables;
    }
    
    int size() const {
      return Size;
    }

}; 
// end of GlobalObservables

#endif